---
title: "Exploratory Data Analysis"
output: html_document
date: "2025-12-05"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Libraries
library(ggplot2)
library(lubridate)
library(dplyr)
library(tidyverse)
library(summarytools)
library(GGally)
library(FSelectorRcpp)
library(kableExtra)


# Data
source("Project/scripts/data_io.R")
source("Project/scripts/data_cleaning.R")
ad_clean <- clean_ad_data(load_ad_data())
```


```{r Repairing Variables, include = FALSE}
# Converting DEVICE_TYPE to a factor
ad_clean$DEVICE_TYPE <- as.factor(ad_clean$DEVICE_TYPE)

# Modifying DEVICE_TYPE according to
# corresponding labels
ad_clean$DEVICE_TYPE <- recode(ad_clean$DEVICE_TYPE,
                         "0" = "Mobile/Tablet",
                         "1" = "Personal Computer",
                         "2" = "Connected TV",
                         "4" = "Tablet",
                         "5" = "Connected Device")

```

```{r Function creation, echo = FALSE}
## Summary function
summary_table <- function(data, var) {
  
  x <- data[[var]]
  
  tibble(
    Min = min(x, na.rm = TRUE),
    `1st Q` = round(quantile(x, 0.25, na.rm = TRUE), 3),
    Median = round(median(x, na.rm = TRUE), 3),
    Mean = round(mean(x, na.rm = TRUE), 3),
    `3rd Q` = round(quantile(x, 0.75, na.rm = TRUE), 3),
    Max = max(x, na.rm = TRUE),
    `NA count` = sum(is.na(x))
  )
}

## Function for pretty histogram
pretty_histogram <- function(data, var) {
  ggplot(data, aes(x = .data[[var]])) +
    geom_histogram(
      bins = 150,
      fill = "#4C9AFF",    # soft blue
      color = "white",
      alpha = 0.85
    ) +
    labs(
      title = paste("Distribution of", var),
      x = var,
      y = "Count"
    ) +
    theme_minimal(base_size = 14) +
    theme(
      plot.title = element_text(face = "bold", size = 16),
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_blank()
    )
}

## Function for pretty boxplot

pretty_boxplot <- function(data, var, y_label = NULL) {
  
  # Default to variable name if y_label not specified 
  if (is.null(y_label)) { y_label <- var } 
  
  # Boxplot 
  ggplot(data, aes(y = .data[[var]])) + 
    geom_boxplot( fill = "#FF7F50",
                  color = "black",
                  outlier.color = "red",
                  outlier.alpha = 0.6,
                  width = 0.3 ) +
    coord_cartesian(ylim = quantile(data[[var]], c(0.05, 0.95), na.rm = TRUE)) + # Zoom to better see graph
    labs( title = paste("Boxplot of", var), y = y_label ) +
    theme_minimal(base_size = 14) +
    theme( plot.title = element_text(face = "bold", size = 16),
           axis.title.x = element_blank(),
           axis.text.x = element_blank(),
           axis.ticks.x = element_blank(),
           panel.grid.major.x = element_blank(),
           panel.grid.minor = element_blank())
}



## Barplot Function
pretty_barplot <- function(data, var, label = NULL) {
  
  # Default to variable name if label not specified
  if (is.null(label)) {
      label <- var
  }
  
  # Barplot
  ggplot(data, aes(x = .data[[var]])) +
    geom_bar(fill = "#6495ED", color = "black") +   # cornflower blue
    labs(
      x = label,
      y = "Count",
      title = paste("Barplot of", var)
    ) +
    theme_minimal(base_size = 14) +
    theme(
      plot.title = element_text(face = "bold", size = 16),
      panel.grid.major.x = element_blank()
    )
}



## Frequency Table Function
pretty_freq <- function(data, var, label = NULL) {
  
  # Default to variable name if label not specified
  if (is.null(label)) {
    label <- var
  }

  # Storing var  
  x <- data[[var]]

  
  # Building frequency table
  freq_table <- x %>%
    table(useNA = "ifany") %>%
    as.data.frame() %>%
    rename(Category = ".", Count = "Freq") %>%
    mutate(Percent = round(Count / sum(Count) * 100, 2)) %>%
    arrange(desc(Count))
  
  # Produce nice kable table
  kable(freq_table, 
        caption = paste("Frequency Table for", label),
        col.names = c(label, "Count", "Percent"),
        align = "lrr") %>%
    kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))
}


## Scatterplot
pretty_xyplot <- function(data, xvar, yvar, x_label = NULL, y_label = NULL) {
  
  # Default  labels to variable names
  if (is.null(x_label)) x_label <- xvar
  if (is.null(y_label)) y_label <- yvar
  
  ggplot(data, aes(x = .data[[xvar]], y = .data[[yvar]])) +
    geom_point(alpha = 0.6, color = "#1f78b4", size = 3) +
    labs(
      title = paste("Scatterplot of", xvar, "vs", yvar),
      x = x_label,
      y = y_label
    ) +
    theme_minimal(base_size = 14) +
    theme(
      plot.title = element_text(face = "bold", size = 16),
      panel.grid.minor = element_blank()
    )
}


```


# Univariate Analysis

## Numerical Variables (Histogram Boxplot)

Looking at a pairs plot we can gain a bit of insight into what the relations are doing, as well as see that some might not be easy to investigate. TIMESTAMP, for example, is difficult to read for Zipcode, Latitude and Longitude.

Using the *information_gain()* function, we can try to look at how significantly variables reduce the uncertainty of the target variable BID_WON. The outcome shows only AUCTION_ID, PUBLISHER_ID, and PRICE as high information gain parameters. Almost all the other variables have lower (but similar to each other) information gain except for the Region variable. This makes sense, given that our data is confined to Oregon.

```{r}
## Pairs generator for the numerical data
# TIMESTAMP gave issues when running this function,
# so I left it out.
ggpairs(ad_clean[, c("DEVICE_TYPE", "DEVICE_GEO_ZIP", "PRICE", "RESPONSE_TIME", "DEVICE_GEO_LAT", "DEVICE_GEO_LONG")])


# Testing for "Predictive Power"
information_gain(BID_WON ~ ., data = ad_clean)
```



### Price

The histogram is very peaked on the left side of the graph, and from the summary table we see there are a few very large outliers causing a right-skewed distribution of price that range up to \$141.25. The boxplot shows a median value of approximately \$0.20, with the IQR ranging from \$0.07 to \$0.57. Price per bid is typically less than \$1.

```{r Price, results = 'asis', echo = FALSE}
# Quick summary of the PRICE variable.
summary_table(ad_clean, "PRICE") %>%
  kable("html", caption = "Summary Statistics for PRICE") %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))

# Histogram of Price
pretty_histogram(ad_clean, "PRICE")

# Boxplot of Price
pretty_boxplot(ad_clean, "PRICE", "Price in Dollars")
```

### Response Time

The histogram of the Response Time variable displays a right-skewed distribution. A majority of the data falls between 50 and 400 milliseconds, with an average response time of 201 milliseconds. The boxplot has a median of 164, with an IQR spanning from 110 to 257 milliseconds. There is a large number of outliers that are cut off by the boxplot, but can be seen trailing toward higher values in the histogram. Response time for the system is typically fast, with a subset of the values being longer than the others.


```{r, results = 'asis'}
# Quick summary of the RESPONSE_TIME variable.
summary_table(ad_clean, "RESPONSE_TIME") %>%
  kable("html", caption = "Summary Statistics for Response Time") %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))

# Histogram of Price
pretty_histogram(ad_clean, "RESPONSE_TIME")

# Boxplot of Price
pretty_boxplot(ad_clean, "RESPONSE_TIME", "Response Time in ms")
```

### Device Geo Latitude

A majority of data falls between 45 and 46 degrees latitude, with the absolute minimum value in the data being 42 degrees. The distribution of latitude is slightly left-skewed, with a peak around 45.5 degrees. The median value shown by the boxplot is 45.514, with the inner quartile range spanning a short distance from 45.3 to 45.525. This is consistent with the information we have about location of the bid data, which was collected from exclusively Oregon.

```{r Latitude, results = 'asis'}

# Quick summary of the DEVICE_GEO_LATITUDE variable.
summary_table(ad_clean, "DEVICE_GEO_LAT") %>%
  kable("html", caption = "Summary Statistics for Latitude") %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))

# Histogram of Price
pretty_histogram(ad_clean, "DEVICE_GEO_LAT")

# Boxplot of Price
pretty_boxplot(ad_clean, "DEVICE_GEO_LAT", "Latitude")

```

### Device Geo Longitude

The longitude variable appears to be somewhat normally distributed in its histogram. Several outliers can be seen trailing from the data toward values of -118, but the majority of the data falls around -122.5 degrees. In the boxplot, the median is centered at -122.83 and the IQR ranges from -122.83 to -122.59. This is an extremely small window of 0.24 degrees, which encompasses the central 50% of the longitude data.

```{r Longitude, results = 'asis'}

# Quick summary of the DEVICE_GEO_LONG variable.
summary_table(ad_clean, "DEVICE_GEO_LONG") %>%
  kable("html", caption = "Summary Statistics for Longitude") %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover"))

# Histogram of Price
pretty_histogram(ad_clean, "DEVICE_GEO_LONG")

# Boxplot of Price
pretty_boxplot(ad_clean, "DEVICE_GEO_LONG", "Longitude")

```

## Categorical Variables (Frequency Chart/ Bar plot)

### Auction ID



### Publisher ID
### Device Type

In Device Type, 2 categories dominate the rest: Personal Computers and Tablets. Accounting for 93.5% of the data, those two devices have a large influence on the dataset as a whole. The lowest type listed is "connected device" accounting for 0.07% of the Device Type variable.

```{r Device Type, results = 'asis'}
pretty_barplot(ad_clean, "DEVICE_TYPE", "")
pretty_freq(ad_clean, "DEVICE_TYPE")
```

### Device Geo City

The most frequently appearing city in this dataset is Portland, by a large margin. Portland accounts for almost 60% of the data, with the next closest being Salem, Beaverton and Hillsboro, each at approximately 3% each. With the density of Portland's population, it has a large influence on the bids data compared to any of the other cities included.

```{r Geo City, results = 'asis'}
pretty_freq(ad_clean, "DEVICE_GEO_CITY")
```

### Device Geo Zip

The zipcode variable is much more evenly distributed, with the largest zip code being only 10% of the data. The higher counts of zipcode entries are from about 24,000 to 45,000, and the smallest zipcodes have counts of just 1.

```{r Zipcode, results = 'asis', echo = FALSE}
pretty_freq(ad_clean, "DEVICE_GEO_ZIP")
```

### Size
### Requested Size
### Bid Won

We can see from the barplot of BID_WON, that there are significantly more losing bids than winning. While the interest in the dataset is in the relation to winning a bid and its price, it is interesting that there are almost 3 times as many losses as there are wins.

```{r Bid Won, results = 'asis', echo = FALSE}
pretty_barplot(ad_clean, "BID_WON")
pretty_freq(ad_clean, "BID_WON")
```
### Device Geo Region

As stated earlier in this document, all datapoints fall within the borders of Oregon, confining analysis to that specific region.

```{r Geo Region, results = 'asis', echo = FALSE}
pretty_freq(ad_clean, "DEVICE_GEO_REGION")
```


# Bivariate Analysis
## Numerical vs Numerical
### Price/Response Time

There are some very high values in the PRICE variable that pull values away from the overall shape. There could be a relation here as the increase in response time seems to lower the PRICE. It could be that slower response times lead to bidders coming in at a lower price, but then losing to others who outbid them. Additionally, we can see some points are separated from the overall shape. These most likely represent bidders either submitting higher priced bids initially, or were fast enough to rebid with a higher price during the same auction.

```{r Price v Response Time}
# Scatterplot
pretty_xyplot(ad_clean, "RESPONSE_TIME", "PRICE", "Response Time (ms)", "Price")

```

### Price/Lat

In the scatterplot of Latitude vs Price, we can see a slight increase in price as the latitude shifts toward the 45.5 area. Here we see an increase in points, which is possibly related to that location being higher in population density. We can also see a similar pattern to the Price vs Response Time graph with values being significantly higher than the other points. Again, this could be a "second round" of bidding in the situation the original bid was rejected.

```{r Price v Lat, results = 'asis', echo = FALSE}
pretty_xyplot(ad_clean, "DEVICE_GEO_LAT", "PRICE", "Latitude", "Price")
```
### Price/Long

Similar to the latitude plot, we can see a large number of the points clustered at approximately -122.5. This is most likely due to high population density at that point. We also continue to see the pattern of higher priced bids above the lower distribution, indicating a second, higher set of bids from those locations.

```{r Price v Longitude, results = 'asis', echo = FALSE}
pretty_xyplot(ad_clean, "DEVICE_GEO_LONG", "PRICE", "Longitude", "Price")
```
### Latitude/Response Time

This scatterplot has data points in a pretty similar pattern across the differing latitudes. There is a significant focus around 45.5, but the data seems well distributed.

```{r Latitude v Response Time, results = 'asis', echo = FALSE}
pretty_xyplot(ad_clean, "DEVICE_GEO_LAT", "RESPONSE_TIME", "Latitude", "Response Time (ms)")
```

### Longitude/Response Time

In this graph, there is a spike of higher response time values at longitude -123. This could be an indicator of a specific location having slower response times than others.

```{r Longitude v Response Time, results = 'asis', echo = FALSE}
pretty_xyplot(ad_clean, "DEVICE_GEO_LONG", "RESPONSE_TIME", "Longitude", "Response Time (ms)")
```

## Numerical vs Categorical
### Price/Bid Won

We can perform a t-test and see that there is a significant different in the mean prices between bids won and bids lost. The boxplot shows the median prices for the bids, categorized by whether or not the bid won. We can see a clear distinction in the distribution of values between the two variables. The plot has been zoomed in for ease of reading.

```{r Price v. Bid Wins}

# T test of means
t.test(PRICE ~ BID_WON, data = ad_clean)

# Boxplot
ggplot(ad_clean, aes(x = ad_clean$BID_WON, y = ad_clean$PRICE)) + 
    geom_boxplot(
        fill = "#FF7F50",
        color = "black",
        outlier.color = "red",
        outlier.alpha = 0.6,
        width = 0.3
    ) +
    coord_cartesian(ylim = quantile(ad_clean$PRICE, c(0.05, 0.95), na.rm = TRUE)) +
    labs(
        title = paste("Boxplot of Price by Bid Win/Loss"),
        x = ("Bid Win/Loss"),
        y = ("Price")
    ) +
    theme_minimal(base_size = 14) +
    theme(
        plot.title = element_text(face = "bold", size = 16),
        axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid.minor = element_blank()
    )
```

### Price/Device Type

The boxplot of Device Type vs Price shows that the categories *Tablet*, *Personal Computer*, and *Mobile/Tablet* have similar medians, but the inner quartile range for the *Tablet* variable is much smaller than the other two. The *Connected Device* category has the highest median of the device types, and also has the largest IQR. There could be an underlying factor that leads to a larger variance among price values in that category. 

```{r Device Type v Price}
# Boxplot
ggplot(ad_clean, aes(x = ad_clean$DEVICE_TYPE, y = ad_clean$PRICE)) + 
    geom_boxplot(
        fill = "#FF7F50",
        color = "black",
        outlier.color = "red",
        outlier.alpha = 0.6,
        width = 0.3
    ) +
    coord_cartesian(ylim = quantile(ad_clean$PRICE, c(0.05, 0.95), na.rm = TRUE)) +
    labs(
        title = paste("Boxplot of Price by Device Type"),
        x = ("Device Type"),
        y = ("Price")
    ) +
    theme_minimal(base_size = 14) +
    theme(
        plot.title = element_text(face = "bold", size = 16),
        axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid.minor = element_blank()
    )

```

### Price/Zip or City
Map graph? Zip and city are too many categories for a boxplot spread.


### Zip or City/Response Time
### Device Type/Response Time

All of the device types have similar median response times, save for the *connected device* category which has a higher value than the others. All the boxplots show outliers, and *connected TV* also has a larger IQR. This could be a difference in hardware, where the method at which TVs interact with the auction is different than the others. Some devices might be optimized differently, causing some bids to be slower. To make that claim, however, we would probably need to know more about the internet traffic during the bidding and other external factors.


```{r Response Time/Price, echo = FALSE}
ggplot(ad_clean, aes(x = ad_clean$DEVICE_TYPE, y = ad_clean$RESPONSE_TIME)) + 
    geom_boxplot(
        fill = "#FF7F50",
        color = "black",
        outlier.color = "red",
        outlier.alpha = 0.6,
        width = 0.3
    ) +
    coord_cartesian(ylim = quantile(ad_clean$RESPONSE_TIME, c(0.05, 0.95), na.rm = TRUE)) +
    labs(
        title = paste("Boxplot of Response Time by Device Type"),
        x = ("Device Type"),
        y = ("Response Time")
    ) +
    theme_minimal(base_size = 14) +
    theme(
        plot.title = element_text(face = "bold", size = 16),
        axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid.minor = element_blank()
    )
```


### Device Type/LatLong

Map, maybe?

### Device Type/Timestamp

This could be a relation of heavier use on certain devices based on time of day.



## Categorical vs Categorical
### Device Type/Zip or City

Map of Device Density?

# Key Findings

# Conclusion?

- Summary

- Limitations

- Future Analysis
